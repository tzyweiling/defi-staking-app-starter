{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = arrayify([]);\n    this._padding = new Uint8Array(wordSize);\n  }\n  get data() {\n    return hexlify(this._data);\n  }\n  get length() {\n    return this._data.length;\n  }\n  _writeData(data) {\n    this._data = concat([this._data, data]);\n    return data.length;\n  }\n  // Arrayish items; padded on the right to wordSize\n  writeBytes(value) {\n    let bytes = arrayify(value);\n    if (bytes.length % this.wordSize) {\n      bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n    }\n    return this._writeData(bytes);\n  }\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n    return bytes;\n  }\n  // BigNumberish items; padded on the left to wordSize\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n  writeUpdatableValue() {\n    let offset = this.length;\n    this.writeValue(0);\n    return value => {\n      this._data.set(this._getValue(value), offset);\n    };\n  }\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    this._offset = 0;\n  }\n  get data() {\n    return hexlify(this._data);\n  }\n  get consumed() {\n    return this._offset;\n  }\n  // The default Coerce function\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n    return value;\n  }\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n    return Reader.coerce(name, value);\n  }\n  _peekBytes(offset, length) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n    if (this._offset + alignedLength > this._data.length) {\n      logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this._data.length,\n        offset: this._offset + alignedLength\n      });\n    }\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n  }\n  readBytes(length) {\n    let bytes = this._peekBytes(0, length);\n    this._offset += bytes.length;\n    // @TODO: Make sure the length..end bytes are all 0?\n    return bytes.slice(0, length);\n  }\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n}","map":{"version":3,"names":["arrayify","concat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","constructor","name","type","localName","dynamic","_throwError","message","value","throwArgumentError","Writer","wordSize","_data","_padding","Uint8Array","data","length","_writeData","writeBytes","bytes","_getValue","from","throwError","BUFFER_OVERRUN","offset","writeValue","writeUpdatableValue","set","Reader","coerceFunc","_offset","consumed","coerce","match","parseInt","toNumber","_coerceFunc","_peekBytes","alignedLength","Math","ceil","subReader","readBytes","readValue"],"sources":["D:/Documents/defi-staking-app-starter/defi-staking-app-starter/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"],"sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = arrayify([]);\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() { return hexlify(this._data); }\n    get length() { return this._data.length; }\n    _writeData(data) {\n        this._data = concat([this._data, data]);\n        return data.length;\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        if (bytes.length % this.wordSize) {\n            bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        let offset = this.length;\n        this.writeValue(0);\n        return (value) => {\n            this._data.set(this._getValue(value), offset);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this._data.length,\n                offset: this._offset + alignedLength\n            });\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n    }\n    readBytes(length) {\n        let bytes = this._peekBytes(0, length);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}