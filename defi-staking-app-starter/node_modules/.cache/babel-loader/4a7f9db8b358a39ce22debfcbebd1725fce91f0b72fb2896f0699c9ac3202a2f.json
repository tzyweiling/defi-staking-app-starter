{"ast":null,"code":"const Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst elliptic = require(\"elliptic\");\nconst rlp = require(\"./rlp\");\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\nconst {\n  keccak256,\n  keccak256s\n} = require(\"./hash\");\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = \"0x\";\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  return checksumAddress;\n};\nconst fromPrivate = privateKey => {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\nconst encodeSignature = _ref => {\n  let [v, r, s] = _ref;\n  return Bytes.flatten([r, s, v]);\n};\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), {\n    canonical: true\n  });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\nmodule.exports = {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature\n};","map":{"version":3,"names":["Bytes","require","Nat","elliptic","rlp","secp256k1","ec","keccak256","keccak256s","create","entropy","innerHex","concat","random","middleHex","outerHex","fromPrivate","toChecksum","address","addressHash","slice","checksumAddress","i","parseInt","toUpperCase","privateKey","buffer","Buffer","ecKey","keyFromPrivate","publicKey","getPublic","publicHash","encodeSignature","_ref","v","r","s","flatten","decodeSignature","hex","length","makeSigner","addToV","hash","signature","sign","canonical","fromString","fromNumber","recoveryParam","pad","fromNat","toString","recover","vals","vrs","toNumber","ecPublicKey","recoverPubKey","encode","module","exports"],"sources":["D:/Documents/defi-staking-app-starter/defi-staking-app-starter/node_modules/web3-eth-accounts/node_modules/eth-lib/lib/account.js"],"sourcesContent":["const Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst elliptic = require(\"elliptic\");\nconst rlp = require(\"./rlp\");\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\nconst { keccak256, keccak256s } = require(\"./hash\");\n\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = \"0x\";\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n  return checksumAddress;\n};\n\nconst fromPrivate = privateKey => {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), { canonical: true });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n  const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n  const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature\n};"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC5B,MAAME,QAAQ,GAAGF,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMG,GAAG,GAAGH,OAAO,CAAC,OAAO,CAAC;AAC5B,MAAMI,SAAS,GAAG,IAAIF,QAAQ,CAACG,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;AAChD,MAAM;EAAEC,SAAS;EAAEC;AAAW,CAAC,GAAGP,OAAO,CAAC,QAAQ,CAAC;AAEnD,MAAMQ,MAAM,GAAGC,OAAO,IAAI;EACxB,MAAMC,QAAQ,GAAGJ,SAAS,CAACP,KAAK,CAACY,MAAM,CAACZ,KAAK,CAACa,MAAM,CAAC,EAAE,CAAC,EAAEH,OAAO,IAAIV,KAAK,CAACa,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;EACvF,MAAMC,SAAS,GAAGd,KAAK,CAACY,MAAM,CAACZ,KAAK,CAACY,MAAM,CAACZ,KAAK,CAACa,MAAM,CAAC,EAAE,CAAC,EAAEF,QAAQ,CAAC,EAAEX,KAAK,CAACa,MAAM,CAAC,EAAE,CAAC,CAAC;EAC1F,MAAME,QAAQ,GAAGR,SAAS,CAACO,SAAS,CAAC;EACrC,OAAOE,WAAW,CAACD,QAAQ,CAAC;AAC9B,CAAC;AAED,MAAME,UAAU,GAAGC,OAAO,IAAI;EAC5B,MAAMC,WAAW,GAAGX,UAAU,CAACU,OAAO,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;EAChD,IAAIC,eAAe,GAAG,IAAI;EAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAED,eAAe,IAAIE,QAAQ,CAACJ,WAAW,CAACG,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,GAAGJ,OAAO,CAACI,CAAC,GAAG,CAAC,CAAC,CAACE,WAAW,CAAC,CAAC,GAAGN,OAAO,CAACI,CAAC,GAAG,CAAC,CAAC;EACpI,OAAOD,eAAe;AACxB,CAAC;AAED,MAAML,WAAW,GAAGS,UAAU,IAAI;EAChC,MAAMC,MAAM,GAAG,IAAIC,MAAM,CAACF,UAAU,CAACL,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;EACrD,MAAMQ,KAAK,GAAGvB,SAAS,CAACwB,cAAc,CAACH,MAAM,CAAC;EAC9C,MAAMI,SAAS,GAAG,IAAI,GAAGF,KAAK,CAACG,SAAS,CAAC,KAAK,EAAE,KAAK,CAAC,CAACX,KAAK,CAAC,CAAC,CAAC;EAC/D,MAAMY,UAAU,GAAGzB,SAAS,CAACuB,SAAS,CAAC;EACvC,MAAMZ,OAAO,GAAGD,UAAU,CAAC,IAAI,GAAGe,UAAU,CAACZ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EACxD,OAAO;IACLF,OAAO,EAAEA,OAAO;IAChBO,UAAU,EAAEA;EACd,CAAC;AACH,CAAC;AAED,MAAMQ,eAAe,GAAGC,IAAA;EAAA,IAAC,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAAH,IAAA;EAAA,OAAKlC,KAAK,CAACsC,OAAO,CAAC,CAACF,CAAC,EAAEC,CAAC,EAAEF,CAAC,CAAC,CAAC;AAAA;AAE/D,MAAMI,eAAe,GAAGC,GAAG,IAAI,CAACxC,KAAK,CAACoB,KAAK,CAAC,EAAE,EAAEpB,KAAK,CAACyC,MAAM,CAACD,GAAG,CAAC,EAAEA,GAAG,CAAC,EAAExC,KAAK,CAACoB,KAAK,CAAC,CAAC,EAAE,EAAE,EAAEoB,GAAG,CAAC,EAAExC,KAAK,CAACoB,KAAK,CAAC,EAAE,EAAE,EAAE,EAAEoB,GAAG,CAAC,CAAC;AAE3H,MAAME,UAAU,GAAGC,MAAM,IAAI,CAACC,IAAI,EAAEnB,UAAU,KAAK;EACjD,MAAMoB,SAAS,GAAGxC,SAAS,CAACwB,cAAc,CAAC,IAAIF,MAAM,CAACF,UAAU,CAACL,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC0B,IAAI,CAAC,IAAInB,MAAM,CAACiB,IAAI,CAACxB,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE;IAAE2B,SAAS,EAAE;EAAK,CAAC,CAAC;EAC9I,OAAOd,eAAe,CAAC,CAAC/B,GAAG,CAAC8C,UAAU,CAAChD,KAAK,CAACiD,UAAU,CAACN,MAAM,GAAGE,SAAS,CAACK,aAAa,CAAC,CAAC,EAAElD,KAAK,CAACmD,GAAG,CAAC,EAAE,EAAEnD,KAAK,CAACoD,OAAO,CAAC,IAAI,GAAGP,SAAS,CAACT,CAAC,CAACiB,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,EAAErD,KAAK,CAACmD,GAAG,CAAC,EAAE,EAAEnD,KAAK,CAACoD,OAAO,CAAC,IAAI,GAAGP,SAAS,CAACR,CAAC,CAACgB,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5N,CAAC;AAED,MAAMP,IAAI,GAAGJ,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;;AAE7B,MAAMY,OAAO,GAAGA,CAACV,IAAI,EAAEC,SAAS,KAAK;EACnC,MAAMU,IAAI,GAAGhB,eAAe,CAACM,SAAS,CAAC;EACvC,MAAMW,GAAG,GAAG;IAAErB,CAAC,EAAEnC,KAAK,CAACyD,QAAQ,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;IAAEnB,CAAC,EAAEmB,IAAI,CAAC,CAAC,CAAC,CAACnC,KAAK,CAAC,CAAC,CAAC;IAAEiB,CAAC,EAAEkB,IAAI,CAAC,CAAC,CAAC,CAACnC,KAAK,CAAC,CAAC;EAAE,CAAC;EACpF,MAAMsC,WAAW,GAAGrD,SAAS,CAACsD,aAAa,CAAC,IAAIhC,MAAM,CAACiB,IAAI,CAACxB,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAEoC,GAAG,EAAEA,GAAG,CAACrB,CAAC,GAAG,CAAC,GAAGqB,GAAG,CAACrB,CAAC,GAAG,CAAC,GAAGqB,GAAG,CAACrB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACvH,MAAML,SAAS,GAAG,IAAI,GAAG4B,WAAW,CAACE,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAACxC,KAAK,CAAC,CAAC,CAAC;EAClE,MAAMY,UAAU,GAAGzB,SAAS,CAACuB,SAAS,CAAC;EACvC,MAAMZ,OAAO,GAAGD,UAAU,CAAC,IAAI,GAAGe,UAAU,CAACZ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EACxD,OAAOF,OAAO;AAChB,CAAC;AAED2C,MAAM,CAACC,OAAO,GAAG;EACfrD,MAAM;EACNQ,UAAU;EACVD,WAAW;EACX8B,IAAI;EACJJ,UAAU;EACVY,OAAO;EACPrB,eAAe;EACfM;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}