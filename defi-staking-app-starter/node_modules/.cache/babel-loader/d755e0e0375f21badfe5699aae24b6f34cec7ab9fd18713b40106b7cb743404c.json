{"ast":null,"code":"/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = _.identity;\n  this.arguments = null;\n  this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\nSubscription.prototype._validateArgs = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) subscription = {};\n  if (!subscription.params) subscription.params = 0;\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params, subscription.subscriptionName);\n  }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\nSubscription.prototype._formatInput = function (args) {\n  var subscription = this.options.subscription;\n  if (!subscription) {\n    return args;\n  }\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n  var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\n\nSubscription.prototype._formatOutput = function (result) {\n  var subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n  var params = [];\n  this.callback = this._extractCallback(args) || _.identity;\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n\n    // replace subscription with given name\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n    this._validateArgs(this.arguments);\n    args = []; // make empty after validation\n  }\n\n  // re-add subscriptionName\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n  return {\n    method: this.options.type + '_subscribe',\n    params: params\n  };\n};\n\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.lastBlock = null;\n  this.removeAllListeners();\n};\n\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function () {\n  var _this = this;\n  var args = Array.prototype.slice.call(arguments);\n  var payload = this._toPayload(args);\n  if (!payload) {\n    return this;\n  }\n\n  // throw error, if provider is not set\n  if (!this.options.requestManager.provider) {\n    setTimeout(function () {\n      var err1 = new Error('No provider set.');\n      _this.callback(err1, null, _this);\n      _this.emit('error', err1);\n    }, 0);\n    return this;\n  }\n\n  // throw error, if provider doesnt support subscriptions\n  if (!this.options.requestManager.provider.on) {\n    setTimeout(function () {\n      var err2 = new Error('The current provider doesn\\'t support subscriptions: ' + _this.options.requestManager.provider.constructor.name);\n      _this.callback(err2, null, _this);\n      _this.emit('error', err2);\n    }, 0);\n    return this;\n  }\n\n  // Re-subscription only: continue fetching from the last block we received.\n  // a dropped connection may have resulted in gaps in the logs...\n  if (this.lastBlock && _.isObject(this.options.params)) {\n    payload.params[1] = this.options.params;\n    payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n  }\n\n  // if id is there unsubscribe first\n  if (this.id) {\n    this.unsubscribe();\n  }\n\n  // store the params in the options object\n  this.options.params = payload.params[1];\n\n  // get past logs, if fromBlock is available\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n\n    // copy the params to avoid race-condition with deletion below this block\n    var blockParams = Object.assign({}, payload.params[1]);\n    this.options.requestManager.send({\n      method: 'eth_getLogs',\n      params: [blockParams]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          var output = _this._formatOutput(log);\n          _this.callback(null, output, _this);\n          _this.emit('data', output);\n        });\n\n        // TODO subscribe here? after the past logs?\n      } else {\n        setTimeout(function () {\n          _this.callback(err, null, _this);\n          _this.emit('error', err);\n        }, 0);\n      }\n    });\n  }\n\n  // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n  if (typeof payload.params[1] === 'object') delete payload.params[1].fromBlock;\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n      _this.method = payload.params[0];\n      _this.emit('connected', result);\n\n      // call callback on notifications\n      _this.options.requestManager.addSubscription(_this, function (error, result) {\n        if (!error) {\n          if (!_.isArray(result)) {\n            result = [result];\n          }\n          result.forEach(function (resultItem) {\n            var output = _this._formatOutput(resultItem);\n\n            // Track current block (for gaps introduced by dropped connections)\n            _this.lastBlock = _.isObject(output) ? output.blockNumber : null;\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            } else {\n              _this.emit('data', output);\n            }\n\n            // call the callback, last so that unsubscribe there won't affect the emit above\n            _this.callback(null, output, _this);\n          });\n        } else {\n          _this.callback(error, false, _this);\n          _this.emit('error', error);\n        }\n      });\n    } else {\n      setTimeout(function () {\n        _this.callback(err, false, _this);\n        _this.emit('error', err);\n      }, 0);\n    }\n  });\n\n  // return an object to cancel the subscription\n  return this;\n};\n\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n  this.options.requestManager.removeSubscription(this.id); // unsubscribe\n  this.id = null;\n  this.subscribe(this.callback);\n};\nmodule.exports = Subscription;","map":{"version":3,"names":["_","require","errors","EventEmitter","formatters","Subscription","options","call","id","callback","identity","arguments","lastBlock","subscription","type","requestManager","prototype","Object","create","constructor","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","subscriptionName","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","subscribe","_this","Array","slice","payload","provider","setTimeout","err1","emit","on","err2","name","isObject","fromBlock","inputBlockNumberFormatter","hasOwnProperty","isFinite","blockParams","assign","send","err","logs","forEach","log","output","addSubscription","error","isArray","resultItem","blockNumber","subscriptionHandler","resubscribe","module","exports"],"sources":["D:/Documents/defi-staking-app-starter/defi-staking-app-starter/node_modules/web3-core-subscriptions/src/subscription.js"],"sourcesContent":["/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\n\"use strict\";\n\nvar _ = require('underscore');\nvar errors = require('web3-core-helpers').errors;\nvar EventEmitter = require('eventemitter3');\nvar formatters = require('web3-core-helpers').formatters;\n\nfunction Subscription(options) {\n    EventEmitter.call(this);\n\n    this.id = null;\n    this.callback = _.identity;\n    this.arguments = null;\n    this.lastBlock = null; // \"from\" block tracker for backfilling events on reconnection\n\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager\n    };\n}\n\n// INHERIT\nSubscription.prototype = Object.create(EventEmitter.prototype);\nSubscription.prototype.constructor = Subscription;\n\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop(); // modify the args array!\n    }\n};\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\nSubscription.prototype._validateArgs = function (args) {\n    var subscription = this.options.subscription;\n\n    if(!subscription)\n        subscription = {};\n\n    if(!subscription.params)\n        subscription.params = 0;\n\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(\n            args.length,\n            subscription.params,\n            subscription.subscriptionName\n        );\n    }\n};\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\nSubscription.prototype._formatInput = function (args) {\n    var subscription = this.options.subscription;\n\n    if (!subscription) {\n        return args;\n    }\n\n    if (!subscription.inputFormatter) {\n        return args;\n    }\n\n    var formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n        return formatter ? formatter(args[index]) : args[index];\n    });\n\n    return formattedArgs;\n};\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param result {Object}\n * @return {Object}\n */\n\nSubscription.prototype._formatOutput = function (result) {\n    var subscription = this.options.subscription;\n\n    return (subscription && subscription.outputFormatter && result) ? subscription.outputFormatter(result) : result;\n};\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nSubscription.prototype._toPayload = function (args) {\n    var params = [];\n    this.callback = this._extractCallback(args) || _.identity;\n\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift();\n\n        // replace subscription with given name\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName;\n        }\n    }\n\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args);\n        this._validateArgs(this.arguments);\n        args = []; // make empty after validation\n\n    }\n\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod);\n    params = params.concat(this.arguments);\n\n\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n    }\n\n    return {\n        method: this.options.type + '_subscribe',\n        params: params\n    };\n};\n\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function(callback) {\n    this.options.requestManager.removeSubscription(this.id, callback);\n    this.id = null;\n    this.lastBlock = null;\n    this.removeAllListeners();\n};\n\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function() {\n    var _this = this;\n    var args = Array.prototype.slice.call(arguments);\n    var payload = this._toPayload(args);\n\n    if(!payload) {\n        return this;\n    }\n\n    // throw error, if provider is not set\n    if(!this.options.requestManager.provider) {\n        setTimeout(function(){\n            var err1 = new Error('No provider set.');\n            _this.callback(err1, null, _this);\n            _this.emit('error', err1);\n        },0);\n\n        return this;\n    }\n\n    // throw error, if provider doesnt support subscriptions\n    if(!this.options.requestManager.provider.on) {\n        setTimeout(function(){\n            var err2 = new Error(\n                'The current provider doesn\\'t support subscriptions: ' +\n                _this.options.requestManager.provider.constructor.name\n            );\n            _this.callback(err2, null, _this);\n            _this.emit('error', err2);\n        },0);\n\n        return this;\n    }\n\n    // Re-subscription only: continue fetching from the last block we received.\n    // a dropped connection may have resulted in gaps in the logs...\n    if (this.lastBlock && _.isObject(this.options.params)){\n        payload.params[1] = this.options.params\n        payload.params[1].fromBlock = formatters.inputBlockNumberFormatter(this.lastBlock + 1);\n    }\n\n    // if id is there unsubscribe first\n    if (this.id) {\n        this.unsubscribe();\n    }\n\n    // store the params in the options object\n    this.options.params = payload.params[1];\n\n    // get past logs, if fromBlock is available\n    if(payload.params[0] === 'logs' && _.isObject(payload.params[1]) && payload.params[1].hasOwnProperty('fromBlock') && isFinite(payload.params[1].fromBlock)) {\n        // send the subscription request\n\n        // copy the params to avoid race-condition with deletion below this block\n        var blockParams = Object.assign({}, payload.params[1]);\n\n        this.options.requestManager.send({\n            method: 'eth_getLogs',\n            params: [blockParams]\n        }, function (err, logs) {\n            if(!err) {\n                logs.forEach(function(log){\n                    var output = _this._formatOutput(log);\n                    _this.callback(null, output, _this);\n                    _this.emit('data', output);\n                });\n\n                // TODO subscribe here? after the past logs?\n\n            } else {\n                setTimeout(function(){\n                    _this.callback(err, null, _this);\n                    _this.emit('error', err);\n                },0);\n            }\n        });\n    }\n\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n\n    if(typeof payload.params[1] === 'object')\n        delete payload.params[1].fromBlock;\n\n    this.options.requestManager.send(payload, function (err, result) {\n        if(!err && result) {\n            _this.id = result;\n            _this.method = payload.params[0];\n            _this.emit('connected', result);\n\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this, function(error, result) {\n                if (!error) {\n                    if (!_.isArray(result)) {\n                        result = [result];\n                    }\n\n                    result.forEach(function(resultItem) {\n                        var output = _this._formatOutput(resultItem);\n\n                        // Track current block (for gaps introduced by dropped connections)\n                        _this.lastBlock = _.isObject(output) ? output.blockNumber : null;\n\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output);\n                        } else {\n                            _this.emit('data', output);\n                        }\n\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        _this.callback(null, output, _this);\n                    });\n                } else {\n                    _this.callback(error, false, _this);\n                    _this.emit('error', error);\n                }\n            });\n        } else {\n            setTimeout(function(){\n                _this.callback(err, false, _this);\n                _this.emit('error', err);\n            },0);\n        }\n    });\n\n    // return an object to cancel the subscription\n    return this;\n};\n\n/**\n * Resubscribe\n *\n * @method resubscribe\n *\n * @returns {void}\n */\nSubscription.prototype.resubscribe = function () {\n    this.options.requestManager.removeSubscription(this.id); // unsubscribe\n    this.id = null;\n\n    this.subscribe(this.callback);\n};\n\nmodule.exports = Subscription;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}